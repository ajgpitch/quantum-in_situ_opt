Simulation of *in situ* optimisation of gates in a quantum simulator
====================================================================
[Alexander Pitchford](http://github.com/ajgpitch), [Benjamin Dive](https://github.com/BenLondon91)

The code in this repository can be used to generate and analyse the data that produce the numerical results in the paper 
[In situ upgrade of quantum simulators to universal computers](https://arxiv.org/abs/1701.01723). 
In the paper we present some numerical results that support the viability and scalability of a method for optimising quantum gates within the quantum simulator itself using a local Choi fidelity measure in the optimisation scheme.

Requirements
------------
This code has primarily been developed and tested with Python 3.6 on a Linux operating system. There is no reason why it should not work on other OS or Python versions. However, the multiprocessing features will not work so well on MS Windows.

[QuTiP](qutip.org) and its prerequistes are required to run most of the scripts and notebooks. It has been tested with version qutip 4.2. Older versions may work as well.

[Jupyter notebook](jupyter.org) is required to run the notebooks.

Downloading
-----------
You should clone or download this repository to use it.

Installation
------------
There are no installation steps. Simply save the files on a computer. There are no extensions that need compiling.

License
-------
You are free to use this software in your research or other activities, with or without modification, provided that the conditions listed in the LICENSE file are satisfied.
We politely request that you acknowledge its source and authors, and cite our paper in any publications that may arise from its use.

Contents and usage
------------------
Most of the code is organised into modules. There are then Python scripts and notebooks that can be run.

### Gate optimisation

This [qso-n_qubit-CNOT](qso-n_qubit-CNOT.py) script will perform the optimisation of a CNOT on quantum system that can be configured in a wide variety of topologies and interaction types. Details of its actions and options are given in the main docstring of the file.

It requires a parameter file. By default, it will use the paramter file specified in `local_settings.ini`. To run it with the default parameters, in a console, enter:

```
$ python qso-n_qubit-CNOT.py 
```

The settings in `local_settings.ini` (e.g. working directory, default parameter file) are expected to change between different machines. You should use the following command to avoid local changes being pushed to the upstream repo:

```
git update-index --skip-worktree local_settings.ini
```

The parameters all link to object attributes. These are described where they are first set to their default values in [qsoconfig.py](qsoconfig.py).

There are other parameter files provided. [params-3qubit-chain-ising.ini](params-3qubit-chain-ising.ini) is simply a copy of the default file. [params-4qubit-ring-heisen.ini](params-4qubit-ring-heisen.ini) is an example with different number of qubits, topology and iteraction type. To run with these parameters:

```
$ python qso-n_qubit-CNOT.py -p params-4qubit-ring-heisen.ini
```

[params-3qubit-chain-ising_equal-xy_ctrl-cNOT1-sens-nq3fet1e-2.ini](params-3qubit-chain-ising_equal-xy_ctrl-cNOT1-sens-nq3fet1e-2.ini) will run an automated search for the numerical accuracy threshold. This involves many more pulse optimisations than the other options and hence may take a long time to run on some systems. Again the `-p` option can be employed to use these parameters.

Copies can be made of the parameter files and they can be selected using the `-p` option.

The [optimize_CNOT.ipynb](optimize_CNOT.ipynb) notebook performs the same functions as the [qso-n_qubit-CNOT](qso-n_qubit-CNOT.py) script. It is in a [Jupyter notebook](jupyter.org) format. It does not use parameter files, instead the object attributes are set directly in the notebook, and can be edited in there.

The script and notebook will utilise as many of your system's processors as specified by the `num_cpus` parameter. 

### Numerical accuracy data interpolation

The data from the automated search for the numerical accuracy threshold can be interploted to provide an estimation of the threshold using the [numer_acc_interpolate.py](numer_acc_interpolate.py) script or [interpolate_num_acc_thresh.ipynb](interpolate_num_acc_thresh.ipynb) notebook. Both are configured to process the example data provided. They can be edited, as described within them, to process any of the three examples, or the data generated by the [qso-n_qubit-CNOT](qso-n_qubit-CNOT.py) script or [optimize_CNOT.ipynb](optimize_CNOT.ipynb) notebook.

### Local fidelity error bound

There are two scripts that can be used to investigate the scaling of the local fidelity error bound. [LocalFidTightnessBound.py](LocalFidTightnessBound.py) processes a range of system sizes. [LocalFidTightnessBound-batch.py](LocalFidTightnessBound-batch.py) processes one system size, designed for use with some batch job scheduler.
